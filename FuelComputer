class FuelComputer
{
  //Member Variables
  float fuelEconomy;
  float fuelConsumption;
  //float fuelEconomyHistory; 
  float range;
  float averageFuelEconomy;
  float [] fuelEconomyHistoryArr;
  float [] fuelEconomyHistoryChart;
  int counter = 0;
  
  FuelComputer()
  {
    fuelEconomyHistoryArr = new float [600];
    fuelEconomyHistoryChart = new float [40];
  }
  
  //Calculating Fuel Economy 
  void calculateFuelEconomy(float totalTravelledDistance, float fuelConsumption)
  {
    if (fuelConsumption < 100000 && fuelConsumption!=0)
    {
    fuelEconomy = (totalTravelledDistance/fuelConsumption);
    //fuelEconomyHistory += fuelEconomy;
    fuelEconomyHistoryArr[sdpx.currentIndex] = fuelEconomy;
      if (sdpx.currentIndex < 40)
      {
        for(int i = 0; i < 40; i++)
        {
          fuelEconomyHistoryChart[i] = fuelEconomyHistoryArr[i];
        }
      }
      else 
      {
        fuelEconomyHistoryChart[39] = fuelEconomyHistoryArr[sdpx.currentIndex];
        for(int j = 0; j < 39; j++)
        {
          fuelEconomyHistoryChart[j] = fuelEconomyHistoryChart[j+1];
        }   
       }
      }
        
      else 
      {
        //do nothing
      }
    }
    
  
  float sumFuelEconomy (int currentIndex2)
  {
    int min = currentIndex2 -60;
    if (min <0)
    min =0;
    int max = currentIndex2;
    float sum =0;
    for (int i=min; i<=max; i++)
    {
      sum += fuelEconomyHistoryArr[i];
    }
    return sum;
  }
  //Calculating Average Fuel Economy, the while loop condition should be changed, im not too sure about it   
  void calculateAverageFuelEconomy(int currentIndex)
  {
    int divisor;
    if (currentIndex > 59)
    divisor = 60;
    else
    divisor = currentIndex+1;
    averageFuelEconomy = sumFuelEconomy(currentIndex)/(divisor);
    //if (currentIndex == 0)
    //averageFuelEconomy = sumFuelEconomy();
//  averageFuelEconomy = fuelEconomyHistory/currentIndex;
  }
  
  //Calculating Range 
  float calculateRange(float averageFuelEconomy, float remainingFuel)
  {
    range = averageFuelEconomy * remainingFuel;
    return range;
  }
 
}
